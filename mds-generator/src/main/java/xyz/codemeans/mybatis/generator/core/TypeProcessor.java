package xyz.codemeans.mybatis.generator.core;

import com.google.common.base.Strings;
import com.google.common.collect.Maps;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import xyz.codemeans.mybatis.generator.annotation.MdsExclude;
import xyz.codemeans.mybatis.generator.config.GenerationDef;

/**
 * @author yuanwq
 */
public class TypeProcessor {

  private final TypeMapping typeMapping;
  private final NamingProcessor namingProcessor;

  public TypeProcessor(TypeMapping typeMapping) {
    this(typeMapping, new NamingProcessor());
  }

  public TypeProcessor(TypeMapping typeMapping, NamingProcessor namingProcessor) {
    this.typeMapping = typeMapping;
    this.namingProcessor = namingProcessor;
  }

  public TypeGeneration process(Class<?> type, GenerationDef def) {
    TypeGeneration generation = new TypeGeneration();
    // all names
    generation
        .setPackageName(namingProcessor.packageName(type, def))
        .setSqlSupportTypeName(
            namingProcessor.sqlSupportTypeName(type, def.getSqlSupportTypeNaming()))
        .setSqlTableTypeName(namingProcessor.sqlTableTypeName(type, def.getSqlTableTypeNaming()))
        .setSqlTableInstanceName(
            namingProcessor.sqlTableInstanceName(type, def.getSqlTableInstanceNaming()))
        .setTableName(namingProcessor.tableName(type, def.getTableNaming()))
        .setQualifiedTableName(namingProcessor.qualifiedTableName(type, def));
    // fields
    Collection<Field> fields = resolveFields(type, def.isInheritField());
    Collection<String> imports = findAllImports(fields);
    List<FieldGeneration> fieldGenerations = fields.stream()
        .map(field -> generateField(field, def))
        .collect(Collectors.toList());
    // content
    StringBuilder sb = new StringBuilder();
    sb.append("/* Generated by mds-generator. DO NOT EDIT! */")
        .append(String.format("package %s;\n\n", generation.getPackageName()))
        .append(imports.stream()
            .map(s -> String.format("import %s;\n", s))
            .collect(Collectors.joining()))
        .append("\n");
    sb.append(String.format("/** @see %s */\n", type.getName()))
        .append("@xyz.codemeans.mybatis.generator.annotation.MdsGenerated\n")
        .append(String.format("public final class %s {\n", generation.getSqlSupportTypeName()));
    String indent = Strings.repeat(" ", def.getIndentSize());
    sb.append(indent)
        .append(String.format("public static final %s %s = new %s();\n",
            generation.getSqlTableTypeName(), generation.getSqlTableInstanceName(),
            generation.getSqlTableTypeName()));
    for (FieldGeneration field : fieldGenerations) {
      sb.append(indent)
          .append(String.format("/** @see %s#%s */\n",
              field.getField().getDeclaringClass().getName(), field.getField().getName()))
          .append(indent)
          .append(String.format("public static final SqlColumn<%s> %s = %s.%s;\n",
              field.getSqlColumnType().getSimpleName(), field.getSqlSupportFieldName(),
              generation.getSqlTableInstanceName(), field.getSqlTableFieldName()));
    }
    sb.append("\n")
        .append(indent)
        .append(String.format("/** @see %s */\n", type.getName()))
        .append(indent)
        .append("@xyz.codemeans.mybatis.generator.annotation.MdsGenerated\n")
        .append(indent)
        .append(String.format("public static final class %s extends SqlTable {\n",
            generation.getSqlTableTypeName()));
    for (FieldGeneration field : fieldGenerations) {
      sb.append(indent).append(indent)
          .append(String.format("/** @see %s#%s */\n",
              field.getField().getDeclaringClass().getName(), field.getField().getName()))
          .append(indent).append(indent)
          .append(String.format("public final SqlColumn<%s> %s = column(\"%s\", JDBCType.%s);\n",
              field.getSqlColumnType().getSimpleName(), field.getSqlTableFieldName(),
              field.getColumnName(), field.getJdbcType().name()));
    }
    sb.append("\n")
        .append(indent).append(indent)
        .append(String.format("public %s() { super(\"%s\"); }\n",
            generation.getSqlTableTypeName(), generation.getQualifiedTableName()))
        .append(indent).append("}\n")
        .append("}");
    generation.setContent(sb.toString());
    generation.setOutfile(namingProcessor.file(def.getOutputDir(), generation.getPackageName(),
        generation.getSqlSupportTypeName()));
    return generation;
  }

  private FieldGeneration generateField(Field field, GenerationDef def) {
    FieldGeneration generation = new FieldGeneration(field);
    generation
        .setSqlColumnType(typeMapping.sqlColumnType(field))
        .setJdbcType(typeMapping.jdbcType(field))
        .setColumnName(namingProcessor.columnName(field, def.getColumnNaming()))
        .setSqlSupportFieldName(
            namingProcessor.sqlSupportFieldName(field, def.getSqlSupportFieldNaming()))
        .setSqlTableFieldName(
            namingProcessor.sqlTableFieldName(field, def.getSqlTableFieldNaming()));
    return generation;
  }

  private Collection<String> findAllImports(Collection<Field> fields) {
    Set<String> imports = new LinkedHashSet<>();
    imports.add("java.sql.JDBCType");
    imports.add("org.mybatis.dynamic.sql.SqlColumn");
    imports.add("org.mybatis.dynamic.sql.SqlTable");
    for (Field field : fields) {
      Class<?> type = field.getType();
      if (type.isArray()) {
        type = type.getComponentType();
      }
      if (type.isPrimitive()
          || type.getPackage().getName().equals("java.lang")) {
        continue;
      }
      imports.add(type.getName());
    }
    return imports;
  }

  private Collection<Field> resolveFields(Class<?> type, boolean inheritField) {
    Map<String, Field> fields = Maps.newLinkedHashMap();
    fields.putAll(findAllFields(type));
    if (inheritField) {
      while (!type.getSuperclass().equals(Object.class)) {
        type = type.getSuperclass();
        findAllFields(type).entrySet()
            .forEach(entry -> fields.putIfAbsent(entry.getKey(), entry.getValue()));
      }
    }
    return fields.values();
  }

  private Map<String, Field> findAllFields(Class<?> type) {
    Map<String, Field> fields = Maps.newLinkedHashMap();
    for (Field field : type.getDeclaredFields()) {
      if (Modifier.isStatic(field.getModifiers())
          || field.getAnnotation(MdsExclude.class) != null) {
        continue;
      }
      fields.put(field.getName(), field);
    }
    return fields;

  }

}
